---
title: "starve-langevin"
output: rmarkdown::html_vignette
vignette: >
    %\VignetteIndexEntry{starve-langevin}
    %\VignetteEnging{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
# knitr::opts_chunk$set(
#     collapse = TRUE,
#     comment = "#>"
# )
```

```{r setup}
library(npmlangevin)
# set.seed(5108)
```

```{r simulate}
sim<- simulate(
    nt = 500,
    nping = 400,
    boundary_sharpness = 0,
    boundary_limit = 1,
    pred_loc_delta = 0.5,
    ping_tau = 0.1 * c(1, 1),
    gamma = 0.05,
    cv_code = 1,
    cv_pars = c(0.15, 0.3, 1),
    # loc_class_probs = c(
    #     G = 0.1,
    #     `3` = 0.1,
    #     `2` = 0.2,
    #     `1` = 0.2,
    #     `0` = 0.2,
    #     A = 0.2,
    #     B = 0.0
    # )
    loc_class_probs = c(
        G = 0.4,
        `3` = 0.3,
        `2` = 0.3,
        `1` = 0.0,
        `0` = 0.0,
        A = 0.0,
        B = 0.0
    )
)
```

```{r}
print(
    with(
        sim$tmap,
        {
            tmap_arrange(
                pred_field + track + pings,
                pred_util + track + pings,
                nrow = 2
            )
        }
    )
)
```


# Data pre-processing

## Fit a random walk to filter locations

```{r}
filtered_locations<- fit_rw(
    locations = sim$pings
)
```

```{r}
filtered_tm<- tm_shape(
        st_cast(st_combine(filtered_locations$track), "LINESTRING")
    ) + tm_lines(col = "red")
filtered_tm + sim$tmap$track + sim$tmap$pings
```

## Find the observed location differences

Note: this procedure only works if no location pings occur at the same time.

```{r}
pings<- filtered_locations$pings
pings$dx<- c(
  tail(sf::st_coordinates(pings)[, 1], -1) - head(sf::st_coordinates(pings)[, 1], -1),
  NA
)
pings$dy<- c(
  tail(sf::st_coordinates(pings)[, 2], -1) - head(sf::st_coordinates(pings)[, 2], -1),
  NA
)
filtered_locations$pings<- pings
```

## Create mesh / persistent graph

```{r}
graph<- make_starve_graph(
  filtered_locations$track,
  max.edge = 0.3,
  cutoff = 0.05
)
```

```{r}
plot(graph$mesh)
```

## Create track prediction graph

```{r}
track_graph<- make_starve_pred_graph(
  pred_coordinates = filtered_locations$track,
  field_coordinates = graph$coordinates
)
```



# Fit the model

## Create data list, parameter list, and TMB object

```{r}
data<- list(
  model = "starve_npmlangevin",
  cv_code = 1, # 1 = Gaussian
  g = list(
    sf::st_coordinates(graph$coordinates),
    lapply(lapply(graph$edge_list, `[[`, 1), `+`, -1),
    lapply(lapply(graph$edge_list, `[[`, 2), `+`, -1)
  ),
  pwg = list(
    coord = matrix(0, nrow = 0, ncol = 2),
    parents = list()
  ),
  coordinates = sf::st_coordinates(filtered_locations$track),
  field_neighbours = lapply(track_graph$parents, `+`, -1),
  time = filtered_locations$track$t,
  location_differences = as.matrix(head(filtered_locations$pings[, c("dx", "dy"), drop = TRUE], -1)),
  location_quality_class = as.numeric(filtered_locations$pings$q) - 1,
  K = as.matrix(loc_class_K[, c("x", "y")])
)
para<- list(
  working_cv_pars = log(c(1, 1)),
  w = matrix(0, nrow = nrow(graph$coordinates), ncol = 2),
  random_walk = matrix(0, nrow = nrow(filtered_locations$track) - 1, ncol = 2),
  # log_gamma = filtered_locations$parameters[["log_gamma"]],
  log_gamma = 0.1 * filtered_locations$parameters[["log_gamma"]],
  working_ping_cov_pars = filtered_locations$parameters[
    names(filtered_locations$parameters) %in% c("working_obs_cov_pars")
  ]
)
map<- list(
  working_cv_pars = as.factor(c(1, NA)),
  log_gamma = as.factor(NA),
  working_ping_cov_pars = as.factor(c(NA, NA, NA))
)

obj<- TMB::MakeADFun(
  data = data,
  para = para,
  # map = map,
  random = c("w", "random_walk"),
  DLL = "npmlangevin_TMB"
)
```

## Optimize model and get standard errors

```{r}
opt<- nlminb(
  obj$par,
  obj$fn,
  obj$gr
)
sdr<- sdreport(
  obj,
  opt$par
)
cv_pars<- as.list(sdr, "Est", report = TRUE)$cv_pars
opt
```

## Get predictions

```{r}
# pwg = make_starve_gg_pred_graph(
#   pred_coordinates = graph$coordinates,
#   field_coordinates = graph$coordinates,
#   cv_pars = as.list(sdr, "Est", report = TRUE)$cv_pars,
#   cv_code = data$cv_code,
#   k = 3
# )
pwg<- make_starve_pred_graph(
  pred_coordinates = graph$coordinates,
  field_coordinates = graph$coordinates,
  k = 10
)
pwg[[2]]<- lapply(
  pwg[[2]],
  function(x) {
    return(
      cbind(
        rep(x, 2),
        rep(c(2, 3), each = length(x))
      )
    )
  }
)
data$pwg[[1]]<- sf::st_coordinates(pwg$coordinates)
data$pwg[[2]]<- lapply(pwg$parents, `+`, -1)
obj<- TMB::MakeADFun(
  data = data,
  para = para,
  random = c("w", "random_walk"),
  DLL = "npmlangevin_TMB"
)
obj$fn(opt$par)
sdr<- sdreport(
  obj,
  opt$par
)

mesh_predictions<- sf::st_as_sf(
  data.frame(
    as.list(sdr, "Est", report = TRUE)$pw,
    as.list(sdr, "Est")$w,
    as.list(sdr, "Std", report = TRUE)$pw,
    as.list(sdr, "Std")$w,
    graph$coordinates
  )
)
colnames(mesh_predictions)[1:6]<- c("g", "dx", "dy", "g_se", "dx_se", "dy_se")
```

## Do some plotting

```{r}
raster_style<- tm_raster(
  style = "cont",
  midpoint = 0,
  interpolate = TRUE,
  palette = "PRGn"
)

tm_shape(sim$pred_field["w"][, , , 1:3]) + raster_style +
  tm_shape(mesh_predictions) + tm_dots(col = c("g", "dx", "dy"), size = 0.2, style = "cont", midpoint = 0, palette = "PRGn") +
  tm_facets(nrow = 1, ncol = 3, free.scales = TRUE) + tm_layout(legend.outside = FALSE)

tmap_arrange(
  tm_shape(sim$pred_field["w"][, , , 1]) + raster_style +
    tm_shape(mesh_predictions) +
    tm_dots(col = c("g"), size = 0.2, style = "cont", midpoint = NA, palette = "PRGn"),
  sim$tmap$track +
    tm_shape(mesh_predictions) +
    tm_dots(col = c("g"), size = 0.2, style = "cont", midpoint = NA, palette = "PRGn"),
  nrow = 1
)
```

```{r}

```